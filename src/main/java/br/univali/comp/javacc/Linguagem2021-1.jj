options {
    STATIC = false;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(Linguagem2021_1)
package br.univali.comp.javacc.gen;
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;
import br.univali.comp.recovery.*;
import br.univali.comp.javacc.gen.Linguagem2021_1.*;

public class Linguagem2021_1 {
    private LexicalOutput lexicalOutput;
    public ParserOutput compile(String input) {
        lexicalOutput = new LexicalOutput();
        try {
            this.program();
        } catch (ParseException e) {
            e.printStackTrace();
            return new ParserOutput(e.currentToken, e.getMessage());
        }
        return null;
    }
    public void lexError(Token t, ParseException pe) {
        this.lexicalOutput.allTokens.add(new ParserOutput(t, pe.getMessage()));
    }
    private void consumeUntil(RecoverySet rs, ParseException pe, String errorMsg, String optional) {
        // TODO: implement this;
    }
    public class LexicalOutput {
        private List<ParserOutput> allTokens = new ArrayList<ParserOutput>();

        public final List<ParserOutput> getErrorOutputs() {
            return allTokens.stream().collect(Collectors.toList());
        }
    }
    public class ParserOutput {
        public final String errorMsg;
        public final String token;
        public final String tokenType;
        public final int startLine;
        public final int endLine;
        public final int startColumn;
        public final int endColumn;

        public ParserOutput(Token token, String errorMsg) {
            this.errorMsg = errorMsg;
            this.token = token.image;
            this.tokenType = this.getTokenType(token);
            this.startLine = token.beginLine;
            this.endLine = token.endLine;
            this.startColumn = token.beginColumn;
            this.endColumn = token.endColumn;
        }

        private String getTokenType(Token t) {
            return Linguagem2021_1.tokenImage[t.kind].replace("<", "").replace(">", "");
        }

        @Override
        public String toString() {
            return String.format("Token: %s - Type: %s - Line: %s - Column: %s", token, tokenType, startLine, startColumn);
        }
    }
}
PARSER_END(Linguagem2021_1)

TOKEN_MGR_DECLS : {
    String fooobar;
}

//Skip the following elements
SKIP : {
    <SPACE : " "> |
    <EOL: ("\n" | "\r" | "\n\r")> |
    <SKIP_MARKERS: "\t" | "\r" | "\r\n" | <SPACE> | <EOL>>
}

SKIP : {
    ":*" : COMMENT                     |
    <COMMENT_LINE: ":|" (~["\n", "\r"])* <EOL> >
 }
<COMMENT> SKIP : {
    "*:" : DEFAULT
}
<COMMENT> MORE : {
    <~[]>
}

TOKEN : {
    <INTEGER_CONSTANT: ["0"-"9"] (["0"-"9"])? (["0"-"9"])? >
}
TOKEN : {
    <FLOAT_CONSTANT: ["0"-"9"] (["0"-"9"])? (["0"-"9"])? (["0"-"9"])? (["0"-"9"])? "." ["0"-"9"] (["0"-"9"])? >
}

TOKEN : {
    <LITERAL_CONSTANT: ("\"" (~["\""])* "\"") | ("'" (~["'"])* "'") >
}

TOKEN [IGNORE_CASE]: {
     <R_PROGRAM: "program">
  |  <R_DEFINE: "define">
  |  <R_NOT: "not">
  |  <R_VARIABLE: "variable">
  |  <R_IS: "is">
  |  <R_VERIFY: "verify">
  |  <R_EXECUTE: "execute">
  |  <R_SET: "set">
  |  <R_TO: "to">
  |  <R_GET: "get">
  |  <R_PUT: "put">
  |  <R_LOOP: "loop">
  |  <R_WHILE: "while">
  |  <R_TRUE: "true">
  |  <R_FALSE: "false">
  |  <R_DO: "do">
  |  <R_NATURAL: "natural">
  |  <R_REAL: "real">
  |  <R_CHAR: "char">
  |  <R_BOOLEAN: "boolean">
}
TOKEN : {
    <IDENTIFIER: ( ( ( (["a" - "z", "A" - "Z"] ("_")?) | ("_" (["a" - "z", "A" - "Z"])?) ) ["0"-"9"] ) | ("_" ["a" - "z", "A" - "Z"]) | (["a" - "z", "A" - "Z"]) )* ( ("_") | (["a" - "z", "A" - "Z"]) | (["a" - "z", "A" - "Z"] "_") | ("_" ["a" - "z", "A" - "Z"]) )>
}

//Special symbols
TOKEN : {
    // Pontuação
  <SS_DOT: ".">
  | <SS_COMMA: ",">
  | <SS_CURLYBRACE_OPEN: "{">
  | <SS_CURLYBRACE_CLOSE: "}">
  | <SS_SQUACEBRACE_OPEN: "[">
  | <SS_SQUAREBRACE_CLOSE: "]">
  | <SS_PARENTESES_OPEN: "(">
  | <SS_PARENTESES_CLOSE: ")">
  | <SS_HEADER:  ":-" >
    // Simbolos aritiméticos
  | <SS_PLUS: "+">
  | <SS_MINUS: "-">
  | <SS_TIMES: "*">
  | <SS_DIVIDE: "/">
  | <SS_PERCENT: "%">
  | <SS_EXPODENTIAL: "**">
  | <SS_MODULO: "%%">
  // Simbolos lógicos
  | <SS_LESS_THAN: "<">
  | <SS_MORE_THAN: ">">
  | <SS_AND: "&">
  | <SS_OR: "|">
  | <SS_NOT: "!">
  | <SS_EQUALS: "==">
  | <SS_NOT_EQUALS: "!=">
  | <SS_LESS_OR_EQUAL_THAN: "<=">
  | <SS_MORE_OR_EQUAL_THAN: ">=">
}

SPECIAL_TOKEN : {
    <ERROR_INVALID_SYMBOL: ["\u0000" - "\u00ff"]> {
        fooobar=image;
    }
    |   <ERROR_UNFINISHED_LITERAL_CONSTANT: ("\"" (~["\""])*) | "'" (~["'"])* >
    |   <ERROR_INTEGER_CONSTANT_FORMAT: ["0"-"9"] ["0"-"9"] ["0"-"9"] (["0"-"9"])+ >
    |   <ERROR_FLOAT_CONSTANT_FORMAT: (["0"-"9"] ["0"-"9"] ["0"-"9"] ["0"-"9"] ["0"-"9"] (["0"-"9"])+ "." (["0"-"9"])*) | ((["0"-"9"])+ "." ["0"-"9"] ["0"-"9"] (["0"-"9"])+) >
}

void program() :
{
 RecoverySet g = First.program;
}
{
try{
    linguagem2021_1(g) <EOF>
}catch (ParseException e){
    consumeUntil(g, e, "Missing incorrect XXXX", "program");
}
}
void linguagem2021_1(RecoverySet g): {}
{
    header(g) <R_PROGRAM> <SS_CURLYBRACE_OPEN> define(g) execute(g) <SS_CURLYBRACE_CLOSE> ident_final(g)
}
void header(RecoverySet g): {
    RecoverySet f = First.header.union(g);
}
{
    try {
        [ <SS_HEADER> <LITERAL_CONSTANT> ]
    } catch(ParseException e) {
        consumeUntil(f, e, "Invalid header expression, missing literal constant before program", "program");
    }
}
void ident_final(RecoverySet g) : {}
{
    [ <IDENTIFIER> ]
}
void all_commands(RecoverySet g) : {}
{
        loops(g)
    |   verify(g)
    |   get(g)
    |   set(g)
    |   put(g)
}
void list_of_commands(RecoverySet g) : {}
{
    all_commands(g) <SS_DOT> list_of_commands_optional(g)
}
void list_of_commands_optional(RecoverySet g) : {}
{
    (all_commands(g) <SS_DOT>)*
}
void list_of_identifiers(RecoverySet g) : {}
{
    <IDENTIFIER> list_of_identifiers_optional(g)
}
void list_of_identifiers_optional(RecoverySet g) : {}
{
    [ <SS_COMMA> list_of_identifiers(g) ]
}
// BEGIN define
void define(RecoverySet g) : {
    RecoverySet f = First.define.union(g);
 }
{
    try {
        [ <R_DEFINE> <SS_CURLYBRACE_OPEN> define_const_and_or_var(g) <SS_CURLYBRACE_CLOSE> ]
    } catch(ParseException e) {
        consumeUntil(f, e, "Missing or incorrect define expression:", "execute");
    }
}
void define_const_and_or_var(RecoverySet g) : {}
{
    define_const_var_opt(g) | define_var_opt_const(g)
}
void define_const_var_opt(RecoverySet g): {}
{
    <R_NOT> <R_VARIABLE> list_of_attribution_with_value(g) define_var_opt(g)
}
void define_var_opt(RecoverySet g) : {}
{
    [<R_VARIABLE> list_of_attribution_without_value(g)]
}
void list_of_attribution_with_value(RecoverySet g) : {}
{
    type(g) <R_IS> list_of_identifiers(g) constant(g) <SS_DOT> [ list_of_attribution_with_value(g) ]
}

void list_of_attribution_without_value(RecoverySet g): {}
{
    type(g) <R_IS> list_of_identifiers(g) <SS_DOT> [ list_of_attribution_without_value(g) ]
}
void define_var_opt_const(RecoverySet g) : {}
{
    <R_VARIABLE> list_of_attribution_without_value(g) define_const_opt(g)
}
void define_const_opt(RecoverySet g) : {}
{
    [<R_NOT> <R_VARIABLE> list_of_attribution_with_value(g) define_var_opt(g)]
}
void type(RecoverySet g) : {
    RecoverySet f = First.type.union(g);
}
{
  try {
    <R_NATURAL> | <R_REAL> |  <R_CHAR> | <R_BOOLEAN>
  } catch(ParseException e) {
    consumeUntil(f, e, "Invalid data type, must be one of: natural, real, char or boolean", "is");
  }
}
// BEGIN loops
void loops(RecoverySet g) : {}
{
    while_expr(g) | do_loop(g)
}
void while_expr(RecoverySet g) : {}
{
    <R_WHILE> expression(g) <R_IS> <R_TRUE> <R_DO> <SS_CURLYBRACE_OPEN> list_of_commands(g) <SS_CURLYBRACE_CLOSE>
}
void do_loop(RecoverySet g) : {}
{
    <R_LOOP> <SS_CURLYBRACE_OPEN> list_of_commands(g) <SS_CURLYBRACE_CLOSE> <R_WHILE> expression(g) <R_IS> <R_TRUE>
}
// BEGIN execute
void execute(RecoverySet g) : {
    RecoverySet f = First.execute.union(g);
}
{
    try {
        <R_EXECUTE> <SS_CURLYBRACE_OPEN> list_of_commands(g) <SS_CURLYBRACE_CLOSE>
    } catch (ParseException e) {
        consumeUntil(g, e, "Missing or invalid execute expression", "}");
    }
}
// BEGIN get
void get(RecoverySet g) : {
   RecoverySet f = First.all_commands.union(g);
}
{
    try {
        <R_GET>  <SS_CURLYBRACE_OPEN> list_of_identifiers(g) <SS_CURLYBRACE_CLOSE>
    } catch(ParseException e) {
        consumeUntil(f, e, "Missing or invalid get expression", "<SS_DOT>");
    }
}
// BEGIN set
void set(RecoverySet g) : {
     RecoverySet f = First.all_commands.union(g);
 }
{
    try {
        <R_SET> expression(g) <R_TO> list_of_identifiers(g)
    } catch(ParseException e) {
        consumeUntil(f, e, "Missing or invalid set expression", "<SS_DOT>");
    }
}
// BEGIN put
void put(RecoverySet g) : {
    RecoverySet f = First.all_commands.union(g);
}
{
    try {
        <R_PUT> <SS_CURLYBRACE_OPEN> list_of_identifiers_and_or_constants(g) <SS_CURLYBRACE_CLOSE>
    } catch(ParseException e) {
        consumeUntil(f, e, "Missing or invalid put expression", "<SS_DOT>");
    }
}
void identifier_or_constant(RecoverySet g) : {}
{
    <IDENTIFIER> | constant(g)
}
void list_of_identifiers_and_or_constants(RecoverySet g) : {}
{
    identifier_or_constant(g) [ <SS_COMMA> list_of_identifiers_and_or_constants(g) ]
}
void constant(RecoverySet g) : {}
{
    <FLOAT_CONSTANT> | <INTEGER_CONSTANT> | <LITERAL_CONSTANT>
}
// BEGIN verify
void verify(RecoverySet g) : {
    RecoverySet f = First.all_commands.union(g);
 }
{
    try {
        <R_VERIFY> expression(g) <R_IS> verify_truefalse(g)
    } catch (ParseException e) {
        consumeUntil(f, e, "Missing or invalid verify expression", "<SS_DOT>");
    }

}
void verify_truefalse(RecoverySet g) : {}
{
    verify_true(g) | verify_false(g)
}
void verify_true(RecoverySet g) : {}
{
    <R_TRUE> <SS_CURLYBRACE_OPEN> list_of_commands(g) <SS_CURLYBRACE_CLOSE> verify_opt_false(g)
}
void verify_opt_false(RecoverySet g) : {}
{
  [
    <R_IS> <R_FALSE> <SS_CURLYBRACE_OPEN> list_of_commands(g) <SS_CURLYBRACE_CLOSE>
  ]
}
void verify_false(RecoverySet g) : {}
{
    <R_FALSE> <SS_CURLYBRACE_OPEN> list_of_commands(g) <SS_CURLYBRACE_CLOSE> verify_opt_true(g)
}
void verify_opt_true(RecoverySet g) : {}
{
  [
    <R_IS> <R_TRUE> <SS_CURLYBRACE_OPEN> list_of_commands(g) <SS_CURLYBRACE_CLOSE>
  ]
}
// BEGIN espressao
void expression(RecoverySet g) : {
    RecoverySet f = First.expression.union(g);
}
{
    try {
            arith_or_logical_expresion(g) expression_dash(g)
        } catch(ParseException e) {
            consumeUntil(f, e, "Invalid arithmetic or logic expression", "is/to");
        }
}
void expression_dash(RecoverySet g) : {}
{
    [
          <SS_EQUALS>     arith_or_logical_expresion(g)
        | <SS_NOT_EQUALS> arith_or_logical_expresion(g)
        | <SS_LESS_THAN>  arith_or_logical_expresion(g)
        | <SS_MORE_THAN>  arith_or_logical_expresion(g)
        | <SS_LESS_OR_EQUAL_THAN> arith_or_logical_expresion(g)
        | <SS_MORE_OR_EQUAL_THAN> arith_or_logical_expresion(g)
    ]
}
void arith_or_logical_expresion(RecoverySet g) : {}
{
    term2(g) least_priority(g)
}
void least_priority(RecoverySet g) : {}
{
    [
         <SS_PLUS> term2(g) least_priority(g)
       | <SS_MINUS> term2(g) least_priority(g)
       | <SS_OR> term2(g) least_priority(g)
    ]
}
void term2(RecoverySet g) : {}
{
    term1(g) medium_priority(g)
}
void medium_priority(RecoverySet g) : {}
{
    [
        <SS_TIMES>   term1(g) medium_priority(g)
      | <SS_DIVIDE>  term1(g) medium_priority(g)
      | <SS_PERCENT> term1(g) medium_priority(g)
      | <SS_MODULO>  term1(g) medium_priority(g)
      | <SS_AND>     term1(g) medium_priority(g)
    ]
}
void term1(RecoverySet g) : {}
{
    element(g) most_priority(g)
}
void most_priority(RecoverySet g) : {}
{
    [
        <SS_EXPODENTIAL> element(g) most_priority(g)
    ]
}
void element(RecoverySet g) : {}
{
        <IDENTIFIER> index(g)
     |  <INTEGER_CONSTANT>
     |  <FLOAT_CONSTANT>
     |  <LITERAL_CONSTANT>
     |  <R_TRUE>
     |  <R_FALSE>
     |  <SS_PARENTESES_OPEN> expression(g) <SS_PARENTESES_CLOSE>
     |  <SS_NOT> <SS_PARENTESES_OPEN> expression(g) <SS_PARENTESES_CLOSE>
}
void index(RecoverySet g) : {}
{
    [ <SS_SQUACEBRACE_OPEN> <INTEGER_CONSTANT> <SS_PARENTESES_CLOSE> ]
}