options {
    STATIC = false;
    UNICODE_INPUT = true;
    DEBUG_LOOKAHEAD = true;
//    DEBUG_PARSER = true;
//    DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(Sintatico)
package br.univali.comp.javacc.gen;


import br.univali.comp.javacc.gen.Sintatico.ParserOutput;
import br.univali.comp.javacc.gen.*;
import java.util.ArrayList;
import java.util.List;

public class Sintatico {
    private List<ParserOutput> output = new ArrayList<ParserOutput>();
    private Boolean hasLexicalErrors = false;

    public List<ParserOutput> getOutput() {
        return output;
    }

    public String analyze() {
        try {
            this.program();
        } catch (ParseException ex) {
            return ex.getMessage();
        }
        return "Syntax is correct";
    }

    public class ParserOutput {
        public final String errorMsg;
        public final String token;
        public final String tokenType;
        public final int startLine;
        public final int endLine;
        public final int startColumn;
        public final int endColumn;

        public ParserOutput(Token token, String errorMsg) {
            this.errorMsg = errorMsg;
            this.token = token.image;
            this.tokenType = this.getTokenType(token);
            this.startLine = token.beginLine;
            this.endLine = token.endLine;
            this.startColumn = token.beginColumn;
            this.endColumn = token.endColumn;
        }

        private String getTokenType(Token t) {
            return SintaticoConstants.tokenImage[t.kind].replace("<", "").replace(">", "");
        }

        @Override
        public String toString() {
            return String.format("Token: %s - Type: %s -Line: %s - Column: %s", token, tokenType, startLine, startColumn);
        }
    }
}
PARSER_END(Sintatico)

TOKEN_MGR_DECLS :
{
}




//Skip the following elements
SKIP : {
    <SPACE : " "> |
    <EOL: ("\n" | "\r" | "\n\r")> |
    <SKIP_MARKERS: "\t" | "\r" | "\r\n" | <SPACE> | <EOL>>
}

SKIP : {
    ":*" : COMMENT                     |
    <COMMENT_LINE: ":|" (~["\n", "\r"])* <EOL> >
 }
<COMMENT> SKIP : {
    "*:" : DEFAULT
}
<COMMENT> MORE : {
    <~[]>
}

TOKEN : {
    <INTEGER_CONSTANT: ["0"-"9"] (["0"-"9"])? (["0"-"9"])? >
}
TOKEN : {
    <FLOAT_CONSTANT: ["0"-"9"] (["0"-"9"])? (["0"-"9"])? (["0"-"9"])? (["0"-"9"])? "." ["0"-"9"] (["0"-"9"])? >
}

TOKEN : {
    <LITERAL_CONSTANT: ("\"" (~["\""])* "\"") | ("'" (~["'"])* "'") >
}

// Removido de acordo com correção prof.
//TOKEN: {
//    <ARITHMETIC: ["+", "-", "*", "/", "%"] | "**" | "%%" >
//}
TOKEN [IGNORE_CASE]: {
     <R_PROGRAM: ("program"){1}>
  |  <R_DEFINE: ("define"){1}>
  |  <R_NOT: ("not"){1}>
  |  <R_VARIABLE: ("variable"){1}>
  |  <R_IS: ("is"){1}>
  |  <R_VERIFY: ("verify"){1}>
  |  <R_EXECUTE: ("execute"){1}>
  |  <R_SET: ("set"){1}>
  |  <R_TO: ("to"){1}>
  |  <R_GET: ("get"){1}>
  |  <R_PUT: ("put"){1}>
  |  <R_LOOP: ("loop"){1}>
  |  <R_WHILE: ("while"){1}>
  |  <R_TRUE: ("true"){1}>
  |  <R_FALSE: ("false"){1}>
  |  <R_DO: ("do"){1}>
  |  <R_NATURAL: ("natural"){1}>
  |  <R_REAL: ("real"){1}>
  |  <R_CHAR: ("char"){1}>
  |  <R_BOOLEAN: ("boolean"){1}>
//  |  <R_IF: "if">
//  |  <R_ELSE: "else">
}
TOKEN : {
    <IDENTIFIER: ( ( ( (["a" - "z", "A" - "Z"] ("_")?) | ("_" (["a" - "z", "A" - "Z"])?) ) ["0"-"9"] ) | ("_" ["a" - "z", "A" - "Z"]) | (["a" - "z", "A" - "Z"]) )* ( ("_") | (["a" - "z", "A" - "Z"]) | (["a" - "z", "A" - "Z"] "_") | ("_" ["a" - "z", "A" - "Z"]) )>
}

// Removido de acordo com correção prof.
//TOKEN : {
//    <LOGICAL: ["<", ">", "&", "|", "!"] | "==" | "!=" | "<=" | ">=">


//TOKEN : {
//    <SPECIAL_SYMBOL: [".", ",", "{", "}", "[", "]", "(", ")"] | ":-" |
//                     // Simbolos aritimético
//                     ["+", "-", "*", "/", "%"] | "**" | "%%" |
//                     // Simbolos lógicos
//                     ["<", ">", "&", "|", "!"] | "==" | "!=" | "<=" | ">="
//    >
//}

//Special symbols
TOKEN : {
    // Pontuação
  <SS_DOT: ("."){1}>
  | <SS_COMMA: (","){1}>
  | <SS_CURLYBRACE_OPEN: ("{"){1}>
  | <SS_CURLYBRACE_CLOSE: ("}"){1}>
  | <SS_SQUACEBRACE_OPEN: ("["){1}>
  | <SS_SQUAREBRACE_CLOSE: ("]"){1}>
  | <SS_PARENTESES_OPEN: ("("){1}>
  | <SS_PARENTESES_CLOSE: (")"){1}>
  | <SS_HEADER:  (":-"){1}>
    // Simbolos aritiméticos
  | <SS_PLUS: ("+")>
  | <SS_MINUS: ("-"){1}>
  | <SS_TIMES: ("*"){1}>
  | <SS_DIVIDE: ("/"){1}>
  | <SS_PERCENT: ("%"){1}>
  | <SS_EXPODENTIAL: ("**"){1}>
  | <SS_MODULO: ("%%"){1}>
  // Simbolos lógicos
  | <SS_LESS_THAN: ("<"){1}>
  | <SS_MORE_THAN: (">"){1}>
  | <SS_AND: ("&"){1}>
  | <SS_OR: ("|"){1}>
  | <SS_NOT:( "!"){1}>
  | <SS_EQUALS: ("=="){1}>
  | <SS_NOT_EQUALS: ("!="){1}>
  | <SS_LESS_OR_EQUAL_THAN: ("<="){1}>
  | <SS_MORE_OR_EQUAL_THAN: (">="){1}>
}

TOKEN : {
    <ERROR_INVALID_SYMBOL: ["\u0000" - "\u00ff"] >
    |   <ERROR_UNFINISHED_LITERAL_CONSTANT: ("\"" (~["\""])*) | "'" (~["'"])* >
    |   <ERROR_INTEGER_CONSTANT_FORMAT: ["0"-"9"] ["0"-"9"] ["0"-"9"] (["0"-"9"])+ >
    |   <ERROR_FLOAT_CONSTANT_FORMAT: (["0"-"9"] ["0"-"9"] ["0"-"9"] ["0"-"9"] ["0"-"9"] (["0"-"9"])+ "." (["0"-"9"])*) | ((["0"-"9"])+ "." ["0"-"9"] ["0"-"9"] (["0"-"9"])+) >
}

void program() : {}
{
    verify() <EOF>
}

void lista_de_comandos() : {}
{
    // TODO: Remove the placeholder token bellow and implement this
    <IDENTIFIER>
}
void lista_de_identificadores() : {}
{
    <IDENTIFIER> lista_opt_de_identificadores()
}
void lista_opt_de_identificadores() : {}
{
    [ <SS_COMMA> lista_de_identificadores() ]
}
// BEGIN define
// TODO: see notes on the BNF google doc, this is a temporary implentation
// <valor> seems equal to <constante>
void define() : {}
{
    [ <R_DEFINE> <SS_CURLYBRACE_OPEN> dec_const_e_ou_var() <SS_CURLYBRACE_CLOSE> ]
}
void lista_atribuicao() : {}
{
    [ atribuicao() lista_atribuicao() ]
}
void atribuicao() : {}
{
    tipo() <R_IS> lista_de_identificadores()
}
void atribuicao_final() : {}
{
    atribuicao() lista_atribuicao()
}
void valor_opcional() : {}
{
    [ constante() ]
}
void dec_const_e_ou_var() : {}
{
    dec_const_opt_var() | dec_var_opt_const()
}
void dec_const_opt_var() : {}
{
    <R_NOT> <R_VARIABLE> atribuicao_final() constante() <SS_DOT> dec_var_opt()
}
void dec_var_opt() : {}
{
    [ <R_VARIABLE> atribuicao_final() valor_opcional() <SS_DOT> ]
}
void dec_var_opt_const() : {}
{
    <R_VARIABLE> atribuicao_final() valor_opcional()  <SS_DOT> dec_const_opt()
}
void dec_const_opt() : {}
{
    [ <R_NOT> <R_VARIABLE> atribuicao_final() constante() ]
}
void tipo() : {}
{
    <R_NATURAL> | <R_REAL> |  <R_CHAR> | <R_BOOLEAN>
}
// BEGIN loops
void loops_repeticao() : {}
{
    while_expr() | do_loop()
}
void while_expr() : {}
{
    <R_WHILE> expressao() <R_IS> <R_TRUE> <R_DO> <SS_CURLYBRACE_OPEN> lista_de_comandos() <SS_CURLYBRACE_CLOSE> <SS_DOT>
}
void do_loop() : {}
{
    <R_LOOP> <SS_CURLYBRACE_OPEN> lista_de_comandos() <SS_CURLYBRACE_CLOSE> <R_WHILE> expressao() <R_IS> <R_TRUE> <SS_DOT>
}
// BEGIN execute
void execute() : {}
{
    <R_EXECUTE> <SS_CURLYBRACE_OPEN> lista_de_comandos() <SS_CURLYBRACE_CLOSE>
}
// BEGIN get
void get() : {}
{
    <R_GET>  <SS_CURLYBRACE_OPEN> lista_de_identificadores() <SS_CURLYBRACE_CLOSE> <SS_DOT>
}
// BEGIN set
void set() : {}
{
    <R_SET> expressao() <R_TO> lista_de_identificadores() <SS_DOT>
}
// BEGIN put
void put() : {}
// TODO: validate this, see note on the BNF google doc
{
    <R_PUT> <SS_CURLYBRACE_OPEN> identificador_ou_constante() lista_de_identificadores_e_ou_constantes() <SS_CURLYBRACE_CLOSE> <SS_DOT>
}
void identificador_ou_constante() : {}
{
// TODO: double check this, see note on the BNF google doc
    <IDENTIFIER> | constante()
}
void lista_de_identificadores_e_ou_constantes() : {}
{
    [ <SS_COMMA> identificador_ou_constante() lista_de_identificadores_e_ou_constantes() ]
}
void constante() : {}
{
    <FLOAT_CONSTANT> | <INTEGER_CONSTANT> | <LITERAL_CONSTANT>
}
// BEGIN verify
void verify() : {}
{
    <R_VERIFY> expressao() <R_IS> verify_truefalse() <SS_DOT> | {
        output.add(new ParserOutput(getToken(1), "Missing or incomplete verify expression"));
    }
}
void verify_truefalse() : {}
{
    verify_true() | verify_false()
}
void verify_true() : {}
{
    <R_TRUE> <SS_CURLYBRACE_OPEN> lista_de_comandos() <SS_CURLYBRACE_CLOSE> verify_opt_false()
}
void verify_opt_false() : {}
{
  [
    <R_IS> <R_FALSE> <SS_CURLYBRACE_OPEN> lista_de_comandos() <SS_CURLYBRACE_CLOSE>
  ]
}
void verify_false() : {}
{
    <R_FALSE> <SS_CURLYBRACE_OPEN> lista_de_comandos() <SS_CURLYBRACE_CLOSE> verify_opt_true()
}
void verify_opt_true() : {}
{
  [
    <R_IS> <R_TRUE> <SS_CURLYBRACE_OPEN> lista_de_comandos() <SS_CURLYBRACE_CLOSE>
  ]
}
// BEGIN espressao
void expressao() : {}
{
    expressao_aritmetica_ou_logica() expressao_dash()
}
void expressao_dash() : {}
{
    [
          <SS_EQUALS>     expressao_aritmetica_ou_logica()
        | <SS_NOT_EQUALS> expressao_aritmetica_ou_logica()
        | <SS_LESS_THAN>  expressao_aritmetica_ou_logica()
        | <SS_MORE_THAN>  expressao_aritmetica_ou_logica()
        | <SS_LESS_OR_EQUAL_THAN> expressao_aritmetica_ou_logica()
        | <SS_MORE_OR_EQUAL_THAN> expressao_aritmetica_ou_logica()
    ]
}
void expressao_aritmetica_ou_logica() : {}
{
    termo2() menor_prioridade()
}
void menor_prioridade() : {}
{
    [
         <SS_PLUS> termo2() menor_prioridade()
       | <SS_MINUS> termo2() menor_prioridade()
       | <SS_OR> termo2() menor_prioridade()
    ]
}
void termo2() : {}
{
    termo1() media_prioridade()
}
void media_prioridade() : {}
{
    [
        <SS_TIMES>   termo1() media_prioridade()
      | <SS_DIVIDE>  termo1() media_prioridade()
      | <SS_PERCENT> termo1() media_prioridade()
      | <SS_MODULO>  termo1() media_prioridade()
      | <SS_AND>     termo1() media_prioridade()
    ]
}
void termo1() : {}
{
    elemento() maior_prioridade()
}
void maior_prioridade() : {}
{
    [
        <SS_EXPODENTIAL> elemento() maior_prioridade()
    ]
}
void elemento() : {}
{
        <IDENTIFIER> indice()
     |  <INTEGER_CONSTANT>
     |  <FLOAT_CONSTANT>
     |  <LITERAL_CONSTANT>
     |  <R_TRUE>
     |  <R_FALSE>
     |  <SS_PARENTESES_OPEN> expressao() <SS_PARENTESES_CLOSE>
     |  <SS_NOT> <SS_PARENTESES_OPEN> expressao() <SS_PARENTESES_CLOSE>
}
void indice() : {}
{
    [ <SS_SQUACEBRACE_OPEN> <INTEGER_CONSTANT> <SS_PARENTESES_CLOSE> ]
}